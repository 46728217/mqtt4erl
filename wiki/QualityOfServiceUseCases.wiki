Some use cases to understand how quality of service levels should affect behaviour of MQTT clients and brokers.

= Client =
== QOS 0 - zero or more deliveries ==
=== Normal Flow ===
 * client sends a QoS 0 message

== QOS 1 - one or more deliveries ==
=== Normal Flow ===
 * client sends a QoS 1 message (PUBLISH, SUBSCRIBE, UNSUBSCRIBE) and stores in Persistent Outbox
 * client receives {PUB,SUB,UNSUB}ACK and removes message from Outbox

=== Death before Acknowledgement ===
 * client sends a QoS 1 message (PUBLISH, SUBSCRIBE, UNSUBSCRIBE) and stores in Persistent Outbox
 * client dies before {PUB,SUB,UNSUB}ACK received 
 * client restarts with same client id and recovers Persistent Outbox
 * client resends messages in Outbox
 * client receives {PUB,SUB,UNSUB}ACK and removes message from Outbox

=== Transfer Interrupted ===
 * client sends a QoS 1 message (PUBLISH, SUBSCRIBE, UNSUBSCRIBE) and stores in Persistent Outbox
 * broker dies before message is transferred 
 * client reconnects with same client id
 * client resends messages in Outbox
 * client receives {PUB,SUB,UNSUB}ACK and removes message from Outbox

== QOS 2 - exactly one delivery ==

= Broker =
== QOS 0 - zero or more deliveries ==
=== Normal Flow ===
 * client A connects and subscribes to topic T
 * client B connects and publishes to topic T with QoS 0
 * broker delivers to all connected subscribers, namely client A

=== Client Subscribes, then Disconnects ===
 * client A connects and subscribes to topic T
 * client A disconnects
 * client B connects and publishes to topic T with QoS 0
 * broker gets list of interested connected subscribers for topic T, namely client A
 * noop: there are no connected subscribers to topic T

== QOS 1 - one or more deliveries ==
=== Normal Flow ===
 * client A connects and subscribes to topic T, requesting QoS 1
 * client B connects and publishes to topic T with QoS 1, placing message in Persistent Outbox
 * broker acknowledges receipt with a PUBACK to client B
 * client B removes message from Persistent Outbox
 * broker delivers message to client A, placing message in Persistent Outbox
 * client A acknowledges by sending a PUBACK to the broker
 * broker removes message from its Persistent Outbox

=== Published QoS > Requested QoS ===
 * client A connects and subscribes to topic T, requesting QoS 0
 * client B connects and publishes to topic T with QoS 1, placing message in Persistent Outbox
 * broker acknowledges receipt with a PUBACK to client B
 * client B removes message from Persistent Outbox
 * broker delivers message as QoS 0 to client A (see QoS 0 use cases above)

=== Client Subscribes, then Disconnects, then Reconnects ===
 * client A connects and subscribes to topic T, requesting QoS 1
 * client A disconnects
 * client B connects and publishes to topic T with QoS 1, placing message in Persistent Outbox
 * broker acknowledges message with a PUBACK sent to client B
 * client B removes message from Persistent Outbox
 * client A is not connected: broker marks message as 'pending' for client A
 * client A connects
 * broker delivers 'pending' message to client A and places it in Persistent Outbox
 * client A acknowledges message with a PUBACK
 * broker removes message from Persistent Outbox

== QOS 2 - exactly one delivery ==